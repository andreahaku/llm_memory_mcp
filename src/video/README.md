# Video Encoding Module

This module implements FFmpeg.wasm-based video encoding for QR code storage, following the Memvid patterns described in the project's video storage implementation plan.

## Overview

The video encoding system converts QR code frames (generated by `QRManager`) into optimized MP4 videos for high-density storage with 50-100x compression ratios. It uses H.264 encoding with parameters specifically tuned for QR code fidelity rather than visual aesthetics.

## Key Components

### `VideoEncoder.ts`
- **`VideoEncoder`** interface: Standard API for video encoding operations
- **`VideoEncodingOptions`**: Configuration for codec, quality, and optimization parameters
- **`QR_ENCODING_PROFILES`**: Pre-configured profiles optimized for different use cases
- **`DEFAULT_QR_ENCODING_OPTIONS`**: Standard settings (H.264, CRF 23, GOP 30, 30fps)

### `WasmEncoder.ts`
- **`WasmFFmpegEncoder`**: FFmpeg.wasm implementation with in-process encoding
- Converts RGBA QR frames to optimized MP4 videos
- Features progress tracking, memory management, and timeout protection
- Automatic WASM initialization and cleanup

### `FrameIndex.ts`
- **`.mvi` file format**: Binary index files for random frame access
- **`MviWriter`/`MviReader`**: Create and read frame index files
- Enables efficient seeking to specific frames in encoded videos
- Stores frame offsets, types (I/P/B), sizes, and timestamps

### `utils.ts`
- **`detectEncoderCapabilities()`**: System capability detection
- **`optimizeEncodingForQR()`**: QR-specific parameter optimization
- **`validateFramesForEncoding()`**: Input validation and compatibility checks
- **`estimateEncodingRequirements()`**: Resource and time estimation

## Usage Example

```typescript
import { QRManager } from '../qr/QRManager.js';
import { WasmFFmpegEncoder, createMviFile } from './index.js';

// 1. Generate QR frames
const qrManager = new QRManager();
const qrResult = await qrManager.encodeToQR('your content here');

// 2. Initialize encoder
const encoder = new WasmFFmpegEncoder();
await encoder.initialize();

// 3. Encode video with progress tracking
const videoResult = await encoder.encode(
  qrResult.frames,
  {
    codec: 'h264',
    crf: 23,        // High quality for QR fidelity
    gop: 30,        // Short GOP for random access
    fps: 30
  },
  (progress) => {
    console.log(`Progress: ${progress.currentFrame}/${progress.totalFrames}`);
  }
);

// 4. Save video and frame index
await fs.writeFile('output.mp4', videoResult.videoData);
await createMviFile(videoResult.frameIndex, 'output.mvi');

// 5. Cleanup
await encoder.dispose();
```

## Encoding Parameters

### QR-Optimized Settings
- **Codec**: H.264 (broad compatibility)
- **CRF**: 20-26 (constant quality, higher = smaller file)
- **GOP Size**: 30 frames (balance between compression and random access)
- **Frame Rate**: 30 fps (standard)
- **Pixel Format**: yuv420p (compatibility)
- **Preset**: medium (balance speed vs compression)
- **Tune**: stillimage (optimized for QR patterns)

### Quality Profiles
- **`ULTRA_HIGH_QUALITY`**: CRF 20, slower preset
- **`HIGH_QUALITY_FAST`**: CRF 23, fast preset
- **`BALANCED`**: CRF 26, medium preset (default)
- **`COMPACT`**: CRF 28, longer GOP for maximum compression

## Frame Index (.mvi) Format

Binary format for efficient frame seeking:

```
Header (32 bytes):
- Magic: "MVIX" (4 bytes)
- Version: uint32 (4 bytes)
- Frame count: uint32 (4 bytes)
- Reserved: 20 bytes

Frame Entry (24 bytes each):
- Frame number: uint32 (4 bytes)
- Byte offset: uint64 (8 bytes)
- Frame size: uint32 (4 bytes)
- Timestamp: uint32 (4 bytes)
- Type + flags: uint32 (4 bytes)
```

## Performance Characteristics

- **Encoding Speed**: 10-40 fps (WASM), varies by frame size
- **Memory Usage**: 3-5x input size for working memory
- **Compression Ratio**: 50-100x for QR content
- **Random Access**: Sub-frame seeking via .mvi index
- **Quality**: Lossless QR module preservation at CRF 20-23

## Dependencies

- **@ffmpeg/ffmpeg**: ^0.12.10 - Main WASM encoder
- **@ffmpeg/util**: ^0.12.1 - Utility functions for WASM
- Automatically downloads WASM binaries from CDN on first use

## Testing

Run the video encoding test:

```bash
node test-video-encoding.js
```

This demonstrates the complete pipeline from QR generation to MP4 creation with frame indexing.